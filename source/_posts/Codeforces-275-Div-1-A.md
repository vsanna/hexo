title: "Codeforces #275 (Div. 1) A"
date: 2015-05-07 00:33:36
tags:
- esplo77
- Codeforces
- Python
---

# A. Diverse Permutation

意外と簡単。Div.2のB問題でいいかもしれない。

## 問題

1～nの数を並び替えた数列$p_1, p_2, ..., p_n$を求めよ。
ただし、以下の条件を満たす必要がある。

$|p_{t-1} - p_t| (1 \leq t \leq n)$がちょうど$k$種類の数字になる

$$ 1 \leq k,n \leq 10^5 $$


## 考え方

とっかかりを掴むため、まずサンプル1を見てみる。
$n=3, k=2$なので、[1,2,3]を並べかえる。
この場合、[1, 3, 2]とすれば、差の数列は[2, 1]となり、丁度2個。

差が[3, 1]になるようにするのは難易度を上げているので、恐らくk個と言われたら差の集合は[k, k-1, ..., 1]となるのだろう、と推測できる。
実際3つ目のサンプル、$n=5, k=2$では、差の配列は[2, 1, 2, 1]となっている。

さて、差の取るべき値が分かったので、実際にどのような動きをすればこの条件を満たすか考える。
色々なパターンを書き出すと見えてくると思うが、「螺旋を描くようにk～1まで取る」と上手くいく事が分かる。

例えば$n=7,k=4$のケースを考える。

- 最初は1から始める
- +4をして、[1, 5]
- -3をして、[1, 5, 2]
- +2をして、[1, 5, 2, 4]
- -1をして、[1, 5, 2, 4, 3]

被らずに取れるのは自明。
この手法では、上記の取り方をした後は以下の条件を満たす。

- 配列の最後が$(1..1+k]$に収まる
- 差の配列が[k, k-1, ..., 1]になる

そのため、残りの数列も簡単に条件を満たせる
（配列の最後の要素から$k+2$はkより小さいため。また、残りは+1してゆけばよく、既に差の配列に含まれているため）。

上記の手順を実装すれば、$O(n)$で解ける。

$$ コード
```python
class Solver(object):

    def run(self):
        n, k = readarray(int)

        res = []
        res.append(1)
        num = 1
        for i in xrange(k, 0, -1):
            if i % 2 == k % 2:
                num += i
            else:
                num -= i
            res.append(num)

        for i in xrange(1 + k + 1, n+1):
            res.append(i)

        print(" ".join(map(str, res)))
```

## 結果
93ms, 6620KB