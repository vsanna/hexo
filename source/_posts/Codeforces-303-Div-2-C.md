title: "Codeforces #303 (Div. 2) C"
date: 2015-05-20 22:53:38
tags:
- esplo77
- Codeforces
- C++11
---


# C. Woodcutters

与作

## 問題

<http://codeforces.com/contest/545/problem/C>

n本の木が生えている（位置を$x_1, x_2, ..., x_n$、木の高さを$h_1, h_2, ..., h_n$とおく）。
それぞれの木を左右に切り倒す（倒さなくても良い）時、最大何本の木を切り倒す事ができるか。

なお、木を切り倒すには、切り倒した際、その木が占める領域に他に何もない状態でなければいけない。
例えば、位置4にある高さ3の木を右に倒すには、4～7の位置に木（倒れているものも含む）がない必要がある。

$$
1 \leq n \leq 10^5 \\\
1 \leq x_i, h_i \leq 10^9
$$

## 考え方

最大値を求める問題。
各木の状態は、「左に倒れている」「そのまま」「右に倒れている」の3つ。
前の木の状態を使って処理できそうな気がする => DPっぽいと当たりを付ける。

次に、何をDPテーブルにするかを考える。
nが大きめなので、$O(n^2)$ではムリ。

良く考えると、覚えるべき状態は、「一つ前の木が右に倒れているか」しか必要ないことが分かる。

* 前の木が左に倒れていようがそのままだろうが、次の木に影響はない。
* 前の木が右に倒れていた際にどの座標まで来るかは$x_i$, $h_i$ですぐ求められるため、位置まで覚える必要はない。

よって、以下のDP表を用意すれば良い。
dp[i][b] = i番目までの木のうち倒された数（i-1番目の木を右に倒した場合b=1）

自分の状態を次の木に渡すので、所謂「配るDP」として書ける。
漸化式が書きにくいので、コードを参照。

なお、最初と最後の木は必ず倒せるので、それを利用すると少し綺麗に書ける。

## コード

```C++
const int N = (1e5) + 10;
int dp[N][2];

int main() {
    cout.setf(ios::fixed, ios::floatfield);
    cout.precision(8);
    ios_base::sync_with_stdio(false);

    int n;
    cin >> n;

    int x[n];
    int h[n];

    rep(i, n)
        cin >> x[i] >> h[i];

    dp[1][0] = 1;
    REP(i, 1, n - 1) {
        rep(j, 2) {
            int prevh = j == 1 ? h[i - 1] : 0;   // 前のが右に倒れてたら
            if (x[i - 1] + prevh < x[i] - h[i])  // 左に倒せる？
                dp[i + 1][0] = max(dp[i + 1][0], dp[i][j] + 1);

            dp[i + 1][0] = max(dp[i + 1][0], dp[i][j]);   // 切らない

            if (x[i] + h[i] < x[i + 1])   // 右に倒せる？
                dp[i + 1][1] = max(dp[i + 1][1], dp[i][j] + 1);
        }
    }

    int res = max(dp[n-1][0], dp[n-1][1]);
    cout << res + 1 << endl;

    return 0;
}
```

## 結果
156ms, 1568KB




