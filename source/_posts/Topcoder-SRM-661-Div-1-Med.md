title: "Topcoder SRM 661 Div.1 Med"
date: 2015-06-28 15:51:16
tags:
- esplo77
- Topcoder
- C++11
---

# 450pt ColorfulLineGraphs

なかなか面白い問題。

## 問題

ノードがN個のグラフを作る。
1～Nのノードに、それぞれK個の色から1つ選び彩色する。
$i<j$を満たし、ノードiとノードjの色が違う際に、ノードjからノードiに有向辺を作ることができる（作らないくても良い）。
同じ色、同じ辺を持つ時に2つのグラフが同じと定義すると、何種類のグラフが作れるかを求めよ。
なお、答えはMで割った余りを出力せよ。

$$
1 \leq N \leq 10^{12} \\\
1 \leq K \leq 10^{12} \\\
2 \leq M \leq 10^6
$$

## 考え方

N, Kが超でかいので、これを踏まえて考える必要がある。

まず最初に考えつくのは、「色のパターンを列挙」「それぞれのパターンで辺のパターンを列挙」するというもの。
当然のごとく、N,Kが大きすぎるのでアウト。

### 漸化式

次に、Nが1つ増えた場合、パターンがいくつ増えるか考える方法を試す。
$N=1$の時、辺は無いのでK通り。
$N=2$の問、2個目のノードの色はK通りある。
また、1個目のノードを固定した時、1個目のノードの色と異なる場合は2→1の辺を作ることができる。

この考えをもとに、一般化してみる。
dp[i]=i個目のノードを追加した際の全パターン数
と定義する。
また、i個目のノードまでの色をカウントし、それぞれの個数を$a_1, a_2, ..., a_k$とする。

(i+1)個目のノードの色を $k_1$ とすると、(i+1)から辺を張るパターン数は、$a_2 + a_3 + ... + a_k$となる。
これに、「辺を張らない場合」があるので1を加えると、辺のパターン数になる。
同様に、(i+1)個目のノードの色が$k_2$となると、辺のパターン数は$a_1 + a_3 + ... + a_k + 1$となる。

(i+1)個目のノードの色を1～kまで求め、全てを合計すると、$(k-1) \cdot \sum_{j=1}^{k}{a_j}$となることがわかる。

ここで、$\sum_{j=1}^{k}{a_j} = i$は定義より明らか。
よって、$(k-1)\cdot i + 1$が、$i$番目までのノードを固定した際に増加するパターン数である。
dp[i]に$i$番目までのパターン数が入っているので、結果として以下の漸化式が導かれる。
$dp[i+1] = dp[i] \cdot \lbrace (k-1)\cdot i + 1 \rbrace$


### 漸化式その後

さて、漸化式が求まったのはいいが、結局$dp[n]$を求めるのはnが大きすぎて無理。
どうすればいいか分からないので、展開してみることにする。
$dp[n] = \lbrace (k-1)\cdot 1 + 1 \rbrace \cdot \lbrace (k-1)\cdot 2 + 1 \rbrace \cdot \lbrace (k-1)\cdot 3 + 1 \rbrace \cdot ... \cdot \lbrace (k-1)\cdot n + 1 \rbrace$

ここで、掛け算している各項が$k-1$ずつ増加していることに注目する。
最終的にmod Mを取るので、これらの項は高々周期Mで同じ値がやってくる。
（周期がぴったりMになるが、線形だからか…？）
というわけで、dp[M]を事前に求めておくと、
ループ分: $dp[M]^{\frac{N}{M}}$
ループからはみ出た分: $N % M$だけループ
という2つを計算すれば良くなる。
ループ分は、高速な累乗計算を使うこと。


## コード
```C++
// a^k
ll fpow(ll a, ll k, int M) {
    ll res = 1ll;
    ll x = a;
    while (k != 0) {
        if ((k & 1) == 1)
            res = (res * x) % M;
        x = (x * x) % M;
        k >>= 1;
    }
    return res;
}

class ColorfulLineGraphs {
    public:
    int rec(ll prev, ll i, ll  K, ll M) {
        return prev * (((i+1) * ((K%M) -1) % M) + 1) % M;
    }

    int countWays(long long N, long long K, int M) {

        ll loop = 1;
        rep(i, M) {
            loop = rec(loop, i, K, M);
        }

        ll rest = 1;
        rep(i, N%M){
            rest = rec(rest, i, K, M);
        }
        return (int)( fpow(loop, N/M, M) * rest % M );
    }
};
```